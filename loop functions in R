#lapply - Loop over a list and evaluate a function on each element, lapply takes three arguments: (1) a list X; (2) a function (or the name of a function) FUN; (3) other
arguments via its ... argument. If X is not a list, it will be coerced to a list using as.list(this is operated by R internal).
#for example:
    x <- list(a = 1:5, b = rnorm(10))
    lapply(x, mean)
    $`a`
    [1] 3

    $b
    [1] -0.04348179
    
 #another example (runif：会用随机数发生器生成符合均匀分布的随机变量,runif 的第一个参数是 你要产生符合均匀分布的随机变量 
 #所以如果我指定runif(1)它就会生成一个随机变量,它还有别的参数，但那些参数具有默认值，所以不需要特别指定)
> x <- 1:4
> lapply(x, runif)
[[1]]
[1] 0.8136308

[[2]]
[1] 0.0853203 0.5379385

[[3]]
[1] 0.2823191 0.5833843 0.4118441

[[4]]
[1] 0.5402627 0.8101085 0.4247117 0.5874183

#lapply and the associated functions make heavy use of what, of what are called anonymous functions. (这个函数在lapply()之外是不存在的)
   x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2))
   x
    $`a`
     [,1] [,2]
[1,]    1    3
[2,]    2    4

    $b
     [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6

   lapply(x, function(elt) elt[1,])
    $`a`
[1] 1 3

    $b
[1] 1 4



#sapply - Same as lapply but try to simplify the result
#If the result is a list where every element is length 1, then a vector is returned
#If the result is a list where every element is a vector of the same length (> 1), a matrix is returned.
#If it can’t figure things out, a list is returned
     x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
     lapply(x,mean) #"list"
$`a`
[1] 2.5

$b
[1] -0.2229306

$c
[1] 1.253847

$d
[1] 4.896378

     sapply(x, mean) #"numeric"
         a          b          c          d 
 2.5000000 -0.2229306  1.2538466  4.8963777 





